#758575DD       {
#758575DD       *****************************************************************************
#758575DD        * A Pascal quicksort.
#758575DD        *****************************************************************************
#758575DD       }
#4D9375         PROGRAM
#DBD7CACC        Sort(input, output);
#DBD7CACC           
#4D9375         CONST
#DBD7CACC               
#758575DD       {
#758575DD        Max array size. 
#758575DD       }
#DBD7CACC               MaxElts = 
#4C9A91         50
#DBD7CACC       ;
#DBD7CACC           
#4D9375         TYPE
#DBD7CACC               
#758575DD       {
#758575DD        Type of the element array. 
#758575DD       }
#DBD7CACC               IntArrType = 
#4D9375         ARRAY
#DBD7CACC        [
#4C9A91         1
#DBD7CACC       ..MaxElts] 
#4D9375         OF
#DBD7CACC        
#CB7676         Integer
#DBD7CACC       ;
#DBD7CACC           
#4D9375         VAR
#DBD7CACC               
#758575DD       {
#758575DD        Indexes, exchange temp, array size. 
#758575DD       }
#DBD7CACC               i, j, tmp, size: 
#CB7676         integer
#DBD7CACC       ;
#DBD7CACC               
#758575DD       {
#758575DD        Array of ints 
#758575DD       }
#DBD7CACC               arr: IntArrType;
#DBD7CACC           
#758575DD       {
#758575DD        Read in the integers. 
#758575DD       }
#DBD7CACC           
#CB7676         PROCEDURE
#DBD7CACC        
#80A665         ReadArr
#DBD7CACC       (
#4D9375         VAR
#DBD7CACC        size: 
#CB7676         Integer
#DBD7CACC       ; 
#4D9375         VAR
#DBD7CACC        a: IntArrType);
#DBD7CACC               
#4D9375         BEGIN
#DBD7CACC                   size := 
#4C9A91         1
#DBD7CACC       ;
#DBD7CACC                   
#4D9375         WHILE
#DBD7CACC        
#4D9375         NOT
#DBD7CACC        eof 
#4D9375         DO
#DBD7CACC        
#4D9375         BEGIN
#DBD7CACC                       readln(a[size]);
#DBD7CACC                       
#4D9375         IF
#DBD7CACC        
#4D9375         NOT
#DBD7CACC        eof 
#4D9375         THEN
#DBD7CACC                           size := size + 
#4C9A91         1
#DBD7CACC                   
#4D9375         END
#DBD7CACC               
#4D9375         END
#DBD7CACC       ;
#DBD7CACC           
#758575DD       {
#758575DD        Use quicksort to sort the array of integers. 
#758575DD       }
#DBD7CACC           
#CB7676         PROCEDURE
#DBD7CACC        
#80A665         Quicksort
#DBD7CACC       (size: 
#CB7676         Integer
#DBD7CACC       ; 
#4D9375         VAR
#DBD7CACC        arr: IntArrType);
#DBD7CACC               
#758575DD       {
#758575DD        This does the actual work of the quicksort.  It takes the
#758575DD                 parameters which define the range of the array to work on,
#758575DD                 and references the array as a global. 
#758575DD       }
#DBD7CACC               
#CB7676         PROCEDURE
#DBD7CACC        
#80A665         QuicksortRecur
#DBD7CACC       (start, stop: 
#CB7676         integer
#DBD7CACC       );
#DBD7CACC                   
#4D9375         VAR
#DBD7CACC                       m: 
#CB7676         integer
#DBD7CACC       ;
#DBD7CACC                       
#758575DD       {
#758575DD        The location separating the high and low parts. 
#758575DD       }
#DBD7CACC                       splitpt: 
#CB7676         integer
#DBD7CACC       ;
#DBD7CACC                   
#758575DD       {
#758575DD        The quicksort split algorithm.  Takes the range, and
#758575DD                     returns the split point. 
#758575DD       }
#DBD7CACC                   
#CB7676         FUNCTION
#DBD7CACC        
#80A665         Split
#DBD7CACC       (start, stop: 
#CB7676         integer
#DBD7CACC       ): 
#CB7676         integer
#DBD7CACC       ;
#DBD7CACC                       
#4D9375         VAR
#DBD7CACC                           left, right: 
#CB7676         integer
#DBD7CACC       ;       
#758575DD       {
#758575DD        Scan pointers. 
#758575DD       }
#DBD7CACC                           pivot: 
#CB7676         integer
#DBD7CACC       ;             
#758575DD       {
#758575DD        Pivot value. 
#758575DD       }
#DBD7CACC                       
#758575DD       {
#758575DD        Interchange the parameters. 
#758575DD       }
#DBD7CACC                       
#CB7676         PROCEDURE
#DBD7CACC        
#80A665         swap
#DBD7CACC       (
#4D9375         VAR
#DBD7CACC        a, b: 
#CB7676         integer
#DBD7CACC       );
#DBD7CACC                           
#4D9375         VAR
#DBD7CACC                               t: 
#CB7676         integer
#DBD7CACC       ;
#DBD7CACC                           
#4D9375         BEGIN
#DBD7CACC                               t := a;
#DBD7CACC                               a := b;
#DBD7CACC                               b := t
#DBD7CACC                           
#4D9375         END
#DBD7CACC       ;
#DBD7CACC                       
#4D9375         BEGIN
#DBD7CACC        
#758575DD       {
#758575DD        Split 
#758575DD       }
#DBD7CACC                           
#758575DD       {
#758575DD        Set up the pointers for the hight and low sections, and
#758575DD                             get the pivot value. 
#758575DD       }
#DBD7CACC                           pivot := arr[start];
#DBD7CACC                           left := start + 
#4C9A91         1
#DBD7CACC       ;
#DBD7CACC                           right := stop;
#DBD7CACC                           
#758575DD       {
#758575DD        Look for pairs out of place and swap 'em. 
#758575DD       }
#DBD7CACC                           
#4D9375         WHILE
#DBD7CACC        left <= right 
#4D9375         DO
#DBD7CACC        
#4D9375         BEGIN
#DBD7CACC                               
#4D9375         WHILE
#DBD7CACC        (left <= stop) 
#CB7676         AND
#DBD7CACC        (arr[left] < pivot) 
#4D9375         DO
#DBD7CACC                                   left := left + 
#4C9A91         1
#DBD7CACC       ;
#DBD7CACC                               
#4D9375         WHILE
#DBD7CACC        (right > start) 
#CB7676         AND
#DBD7CACC        (arr[right] >= pivot) 
#4D9375         DO
#DBD7CACC                                   right := right - 
#4C9A91         1
#DBD7CACC       ;
#DBD7CACC                               
#4D9375         IF
#DBD7CACC        left < right 
#4D9375         THEN
#DBD7CACC                                   swap(arr[left], arr[right]);
#DBD7CACC                           
#4D9375         END
#DBD7CACC       ;
#DBD7CACC                           
#758575DD       {
#758575DD        Put the pivot between the halves. 
#758575DD       }
#DBD7CACC                           swap(arr[start], arr[right]);
#DBD7CACC                           
#758575DD       {
#758575DD        This is how you return function values in pascal.
#758575DD                             Yeccch. 
#758575DD       }
#DBD7CACC                           Split := right
#DBD7CACC                       
#4D9375         END
#DBD7CACC       ;
#DBD7CACC                   
#4D9375         BEGIN
#DBD7CACC        
#758575DD       {
#758575DD        QuicksortRecur 
#758575DD       }
#DBD7CACC                       
#758575DD       {
#758575DD        If there's anything to do... 
#758575DD       }
#DBD7CACC                       
#4D9375         IF
#DBD7CACC        start < stop 
#4D9375         THEN
#DBD7CACC        
#4D9375         BEGIN
#DBD7CACC                           splitpt := Split(start, stop);
#DBD7CACC                           QuicksortRecur(start, splitpt-
#4C9A91         1
#DBD7CACC       );
#DBD7CACC                           QuicksortRecur(splitpt+
#4C9A91         1
#DBD7CACC       , stop);
#DBD7CACC                       
#4D9375         END
#DBD7CACC                   
#4D9375         END
#DBD7CACC       ;
#DBD7CACC               
#4D9375         BEGIN
#DBD7CACC        
#758575DD       {
#758575DD        Quicksort 
#758575DD       }
#DBD7CACC                   QuicksortRecur(
#4C9A91         1
#DBD7CACC       , size)
#DBD7CACC               
#4D9375         END
#DBD7CACC       ;
#DBD7CACC           
#4D9375         BEGIN
#DBD7CACC               
#758575DD       {
#758575DD        Read 
#758575DD       }
#DBD7CACC               ReadArr(size, arr);
#DBD7CACC               
#758575DD       {
#758575DD        Sort the contents. 
#758575DD       }
#DBD7CACC               Quicksort(size, arr);
#DBD7CACC               
#758575DD       {
#758575DD        Print. 
#758575DD       }
#DBD7CACC               
#4D9375         FOR
#DBD7CACC        i := 
#4C9A91         1
#DBD7CACC        
#4D9375         TO
#DBD7CACC        size 
#4D9375         DO
#DBD7CACC                   writeln(arr[i])
#DBD7CACC           
#4D9375         END
#DBD7CACC       .
#758575DD       {
#758575DD        From http://sandbox.mc.edu/~bennet/cs404/doc/qsort_pas.html 
#758575DD       }
